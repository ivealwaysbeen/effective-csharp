# effective-csharp

## 개요
Effecitve C# 책에서 나오는 내용을 직접 구현해보고 공유하는 공간입니다

-----------------------------

## C# 언어요소
1. 지역변수를 선언할 때는 var를 사용하는 것이 낫다
> * 리턴 타입에 대한 정확한 반환 타입을 얻을 수 있다.
> * var를 사용할 때는 변수명 또는 리턴하는 메소드명에서 타입을 유추할 수 있도록 한다.
> * 내장된 형변환을 사용할 경우, 반환 타입을 유추하기 힘들다.


2. const보다는 readonly가 좋다
> * C#은 컴파일타임 상수 const와 런타임 상수 readonly 두 유형의 상수를 가진다.
> * const는 더 빠르긴 하지만 readonly에 비해 유연성이 떨어진다.
>   + const는 메서드 내부에서 선언할 수 없다. readonly는 가능하다(인스턴스마다 다른 상수값을 가질 수 있게 된다)
>   + const는 내장 자료형만 선언 가능하다.
> * const는 컴파일 타임에 값으로 대체되고, readonly는 컴파일 타임에 상수에 대한 참조로 컴파일된다.


3. 캐스트보다는 is, as가 좋다 
> * 캐스트를 사용할 경우, try-catch 문을 사용해야할 뿐만 아니라, 널 체크까지 해줘야 한다. 반면에 as는 널 체크만 해주면 된다.
> * 더 방어적인 코드를 작성하기 위해서는 is 연산자를 먼저 사용해본다.
> * as나 is 연산자는 사용자 정의 형변환을 사용할 수 없다. 때문에 항상 동일한 결과를 반환한다.
> * 캐스팅을 사용하면 사용자 정의 형변환을 사용할 수 있지만, 컴파일 타임에 객체의 타입을 기준으로 추적하기 때문에 원하는 결과를 얻기 힘들다.(코드도 흉해진다)

4. string.Format()을 보간 문자열로 대체하라
> * expression이라고 하기에는 if/else while가 같은 제어 흐름을 변경할 수 없다.
> * 보간 문자열을 사용하면 인자를 누락하는 실수를 줄일 수 있다.
> * 박싱을 막기 위해서는 toString()을 사용하여 미리 변환한다.
> * 보간 문자열 안에 다른 보간 문자열을 포함시킬 수 있다.

5. 문화권별로 다른 문자열을 생성하려면 FormattableString을 사용하라
> * FormattableString 타입의 객체를 활용하면 문화권과 언어를 지정하여 문자열을 생성할 수 있다.

6. nameof() 연산자를 적극 활용하라
> * 심볼 그 자체를 해당 심볼을 포함하는 문자열로 대체해준다.
> * 심볼의 이름을 평가하며, 타입, 변수, 인터페잇스, 네임스페이스에 대하여 사용할 수 있다.
> * 제네릭 타입을 사용할 경우에는 모든 타입 매개변수를 지정한 닫힌 제네릭 타입만 사용할 수 있다.
> * 정규화된 이름(System.Int.MaxValue)을 사용하더라도 항상 로컬 이름(MaxValue)을 반환한다.
> * 문자열을 하드코딩 하는 대신 nameof()를 사용하면 이름 바꾸기 작업을 수행할 때도 실수를 줄일 수 있다.

7. 델리게이트를 이용해 콜백을 표현해라

